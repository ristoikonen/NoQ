
To leave the DLL Hell
================================


NuGet 'If it's not broke; don't prevent it.' Or 'Innocent until proven guilty.'


Binding Redirect
-------------------
Suppose you have application A that references library B, and also library C of version 1.1.2.5. 
Library B in turn also references library C, but of version 1.1.1.0. 
Now we have a conflict, because you cannot load different versions of the same assembly at runtime. 
To resolve this conflict you might use binding redirect, usually to the new version (but can be to the old too). 

You do that by adding the following to app.config file of application A, 
under configuration > runtime > assemblyBinding section (see here for an example of full config file)

<dependentAssembly>
    <assemblyIdentity name="C"  
                      publicKeyToken="32ab4ba45e0a69a1"  
                      culture="en-us" />  

    <bindingRedirect oldVersion="1.1.1.0" newVersion="1.1.2.5" />  
</dependentAssembly>

You can also specify a range of versions to map:

<bindingRedirect oldVersion="0.0.0.0-1.1.1.0" newVersion="1.1.2.5" />  
Now library B, which was compiled with reference to C of version 1.1.1.0 will use C of version 1.1.2.5 at runtime. Of course, you better ensure that library C is backwards compatible or this might lead to unexpected results.
You can redirect any versions of libraries, not just major ones.

********************************************************************************
Buy a proper Code Signing Certificate and apply Authenticode to the assembly
********************************************************************************


If you have a library that will be consumed in other project and uses a third party assembly 
to do some taks you can merge both assemblies hidding the reference.

Scenario
You use the Ionic.Zip.dll assembly, if you deploy your library as-is, you can generate version conflicts 
if the users are using another (incompatible) version of Ionic.Zip.dll

Solution
Add a msbuild step or a Post-Build event with code like:

ILMerge.exe /internalize /out:"MyLibrary.Merged.dll" "MyLibrary.dll" "Ionic.Zip.dll"

Now you have a MyLibrary.Merged.dll that contains all the code in Ionic.Zip.dll but with all members 
with internal visibility

Hints:
remove /t:dll if the destination is executable
use /ndebug if you don't need the pdb's
use /targetplatform:v4 if the destination must use .Net 4.0 runtime (by  default is .net 2.0)

Home: http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx
ILMergeGUI: http://ilmergegui.codeplex.com/


Do the Newtonsoft.Json versioning trick where the assembly version doesn’t change across releases
even though I hate this idea on principle.

Newtonsoft.Json changed their versioning strategy so that they locked the assembly version but let the real 
Nuget version float within semantically versioned releases. Even though that does a lot to eliminate binding conflicts, 
I still dislike that strategy because it’s a potentially confusing lie to consumers. 
Indication that strong naming needs to be permanently changed inside the CLR itself.

Be cautious consuming any strong named library that revisions often.

Strong-named assembly (check <codebase> with version attribute -> to utilise strong-names)
--------------------------------------------------------------------------------------------
A strong named assembly is generated by using the private key that corresponds to the public key 
distributed with the assembly, and the assembly itself. 
The assembly includes the assembly manifest, which contains the names and hashes of 
all the files that make up the assembly. Assemblies that have the same strong name should be identical.

Do not rely on strong names for security. They provide a unique identity only.

benefits, such as versioning and naming protection. Strong-named assemblies can be installed in the Global Assembly Cache, which is required to enable some scenarios.

Strong-named assemblies are useful in the following scenarios:

-You want to enable your assemblies to be referenced by strong-named assemblies, or you want to give friend access to your assemblies from other strong-named assemblies.

-An app needs access to different versions of the same assembly. This means you need different versions of an assembly to load side by side in the same app domain without conflict. 
	For example, if different extensions of an API exist in assemblies that have the same simple name, strong-naming provides a unique identity for each version of the assembly.

-You do not want to negatively affect performance of apps using your assembly, so you want the assembly to be domain neutral. This requires strong-naming because a domain-neutral assembly 
	must be installed in the global assembly cache.

-When you want to centralize servicing for your app by applying publisher policy, which means the assembly must be installed in the global assembly cache.

-If you are an open-source developer and you want the identity benefits of a strong-named assembly, consider checking in the private key associated with an assembly into your source control system.

BTW:To disable strongname validation for all assemblies with a given public key token: sn.exe -Vr *,<public key hex token>

